---
title: "Simple method to correlate infection spread and isolation"
output: html_notebook
---

# Logistic function

```{r}
library(latex2exp)
library(ggplot2)
# Differential equations solver
library(deSolve)
df.logistic <- function (t, y, parms) {
  list(parms["r"] * y * (1-y/parms["K"]))
}
t_final <- 300
times <- seq(from=1, to=t_final, by=1)
y_initial <- c(y=1)
parms <- c(r=0.04, K=350)
out <- ode(func=df.logistic, y=y_initial, 
           times=times, parms=parms)
# Normalize (standardize) the data

for (i in 1:2) {
  out[,i] <- out[,i] / max(out[,i])
}
# Create the data frame from logistic output
dfl <- data.frame(t=out[,1], y=out[,2])
# Plot
pl_title <- "Logistic function"
pl <- ggplot(dfl, aes(x=t, y=y)) +
      geom_line(color="blue") +
      labs(title=pl_title, y="cases\n", x = "time") +
      annotate("text", x=.125, y=.9, 
               label=TeX("\\frac{dy}{dt} = r y (1 - y / K)"), 
               size=4)
pl
#text(.125, .9, expression(paste(frac("dy","dt"), " = r y (1 - y/K)", sep=" ")))
```
# Data

The accumulated number of cases and the average of isolation level for all 
cities in the São Paulo State were stored in a file called "covid19-sp-BR.csv".
 The first and the last rows correspond to the timeline used in the study.

A row in the CSV file looks like this:

```{}
20200421;805;0.5810548129496403
```

The fields are separated by semicolon ";" with the first column representing 
the date in the format YYYYMMDD (Y - year characters, M - month characters, D - day characters),
the second column represent the number of cases on that day and the third the isolation level 
assessed during the day.


```{r}
# Current directory
WD <- getwd();
# Data file name
FN <- "covid19-sp-BR.csv"
file_path <- file.path(WD, FN);
# Read CSV file organizing the data according to columns
df <- read.csv(file_path, header = TRUE, sep = ";");
```

The time step or window `W` is the only input needed to the method.
 The value of `W` was adopted after a set of tests performed to 
 check which value causes a better correlation in the curves 
 for the model and estimated data. This high correlation means that 
 the isolation level in that time step affects the number of cases in the 
 next time step. The cases are summed and isolation levels 
 are averaged in each time step `W`


```{r}
# Time step in days (window)
W <- 5;
# Number of rows in the data set
N <- nrow(df)
# Number of time steps (windows)
NW <- floor(N/W);
# Vectors to store the number of cases and average 
# of isolation levels at each time step
empirical <- vector("numeric", NW)
level <- vector("numeric", NW)
for (i in 1:NW) {
  k <- i*W
  # Assign the sum the cases from rows [1,k] to ith time step
  empirical[i] = sum(df[1:k, 2])
  # Assign the sum the cases from rows [j,k] to ith time step
  j = (i-1)*W + 1
  level[i] = mean(df[j:k, 3])
}
dfdt <- data.frame(level, empirical)
# Add time steps to data frame
time <- seq(from=1, to=length(dfdt$level), by=1)
dfdt$time <- time
```

# Fitting

Logistic function in the exponential form:

$$𝑓(t)= {K \over 1 + ({ K-m \over m }) e^{−rt}}$$


where:
t is a list of values representing the time steps;
n_m is the sigmoid's midpoint;
K is the the maximum value for n;
r is the the logistic growth rate.

The logistic function is used to fit the number of cases and the 
fitting parameters are used in the estimation phase.


```{r}
library(ggplot2)
library(minpack.lm)
temp <- data.frame(y = dfdt$empirical, x = seq(length(dfdt$empirical)))
logistic.model <- nlsLM(y ~ (K/ (1 + ((K-m)/m)*exp(- r * x))), 
                        data = temp, 
                        start = list(K = 1, m=1, r = 0.1))
summary(logistic.model)
fitting <- predict(logistic.model, list(x = temp$x))
dfdt$fitting <- fitting

# Plot
p_title <- paste("Fitting of empirical data using", W, "days as time step")
colors <- c("empirical" = "red", "fitted" = "blue")
p <- ggplot(dfdt, aes(x=time, y=empirical)) + 
     geom_point(color = "red") +
     geom_line(aes(x=time, y=fitting, color = "blue"), size=1) +
     labs(title=p_title, y="cases\n", x = "time") +
     scale_color_identity(name = "",
                          breaks = c("blue"),
                          labels = c("fit"),
                          guide = "legend")
p

# Test the correlation of the empirical data and the model
cor.test(temp$y, dfdt$fitting, method=c("pearson"))

```
# Estimating

The estimation is performed after the calculation of $\lambda$
 is done by:
 
 $$\lambda = r_{fit}\, \overline{i\ },$$
where $r_{fit}$ is the logistic growth factor obtained from 
fitting and $\overline{i }$ is the average of all isolation 
level values.

The $\lambda$ value is used to estimate the number of cases 
$n(t+dt)$ using the logistic function in the exponential form, 
substituting the parameters by the fitted ones with the exception 
of growth factor from previous time step that now depends on 
isolation level of that step and it's calculated by

$$r(t) = {\lambda\over i(t)}, $$
and the logistic function calculates the current number of cases based 
on the previous time step isolation level using:

$$n(t+dt)= {K \over 1 + ({ K-n_m \over n_m }) e^{−r(t)\, t}}$$

```{r}
# Estimation of cases using fitted parameters and 
# the mean of isolation level at each time step.
exp.logistic <- function(t, r_t, K, m) {
    y <- K / (1 + ((K-m)/m)*exp(-r_t * t))
    y
}

# Calculate the constant alpha
r_fit <- coef(logistic.model)["r"]
lamb <- r_fit * mean(dfdt$level)

K <- coef(logistic.model)["K"]
m <- coef(logistic.model)["m"]
# Estimate the number of cases N(t+dt)
estimated = vector("numeric", NW)
# Estimate the first case manually, but not the rest.
estimated[1] = 1
for (t in 2:NW) {
  r_t <- lamb/dfdt$level[t]
  # This is t+dt compared with empirical time
  estimated[t] <- exp.logistic(t, r_t, K, m)
}
dfdt$estimated <- estimated

# subplot in 2 rows
library(ggplot2)
library(reshape2)
p1_title = paste("Estimation of cases using", W, "days as time step")
p1_label = c("empirical", "estimated")
# melt the data to a long format
temp <- data.frame(time=dfdt$time, empirical=dfdt$empirical, estimated=dfdt$estimated)
df2dt <- melt(data = temp, id.vars = "time")
p1 <- ggplot(data = df2dt, aes(x = time, y = value, color = variable)) + 
      geom_point() + 
      labs(title=p1_title, y="cases\n", x = "") +
      scale_colour_discrete(name = "data type", labels = c("empirical", "estimated"))

# plot 2
p2 <- ggplot(data = dfdt, aes(x = time, y = level, color = "")) + 
      geom_point() + 
      labs(y="level\n", x = "time") +
      scale_colour_discrete(name = "isolation", labels = c(""))
      
library(grid)
grid.newpage()
grid.draw(rbind(ggplotGrob(p1), ggplotGrob(p2), size = "last"))

# Test the correlation of the empirical and estimated data.
cor.test(dfdt$empirical, dfdt$estimated, method=c("pearson"))
```
