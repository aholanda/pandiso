---
title: "Simple method to correlate infection spread and isolation"
output: html_notebook
---

# Logistic function

```{r}
library(deSolve)
df.logistic <- function (t, y, parms) {
  list(r * y * (1-y/k))
}
t_final <- 280
times <- seq(from=1, to=t_final, by=1)
y_initial <- c(y=1)
ode_parms <- c(r=0.1, k=0.5)
out <- ode(func=df.logistic, y=y_initial, 
           times=times, parms=ode_parms)
plot(out, xlab="t", ylab="y", main="Logistic function")
```
# Data

The accumulated number of cases and the average of isolation level for all 
cities in the São Paulo State were stored in a file called "covid19-sp-BR.csv".
 The first and the last rows correspond to the timeline used in the study.

A row in the CSV file looks like this:

```{}
20200421;805;0.5810548129496403
```

The fields are separated by semicolon ";" with the first column representing 
the date in the format YYYYMMDD (Y - year characters, M - month characters, D - day characters),
the second column represent the number of cases on that day and the third the isolation level 
assessed during the day.


```{r}
# Current directory
WD <- getwd();
# Data file name
FN <- "covid19-sp-BR.csv"
file_path <- file.path(WD, FN);
# Read CSV file organizing the data according to columns
cov_data <- read.csv(file_path, header = TRUE, sep = ";");
```

The time step or window `W` is the only input needed to the method.
 The value of `W` was adopted after a set of tests performed to 
 check which value causes a better correlation in the curves 
 for the model and estimated data. This high correlation means that 
 the isolation level in that time step affects the number of cases in the 
 next time step. The cases are summed and isolation levels 
 are averaged in each time step `W`


```{r}
# Time step in days (window)
W <- 5;
# Number of rows in the data set
N <- nrow(cov_data)
# Number of time steps (windows)
NW <- floor(N/W);
# Vectors to store the number of cases and average 
# of isolation levels at each time step
cases_dt <- vector("numeric", NW)
lvels_dt <- vector("numeric", NW)
for (i in 1:NW) {
  k <- i*W
  # Assign the sum the cases from rows [1,k] to ith time step
  cases_dt[i] = sum(cov_data[1:k, 2])
  # Assign the sum the cases from rows [j,k] to ith time step
  j = (i-1)*W + 1
  lvels_dt[i] = mean(cov_data[j:k, 3])
}
```

# Fitting

Logistic function in the exponential form:

$$𝑓(t)= {K \over 1 + ({ K-m \over m }) e^{−rt}}$$


where:
t is a list of values representing the time steps;
n_m is the sigmoid's midpoint;
K is the the maximum value for n;
r is the the logistic growth rate.

The logistic function is used to fit the number of cases and the 
fitting parameters are used in the estimation phase.


```{r}
library(minpack.lm)
temp <- data.frame(y = cases_dt, x = seq(length(cases_dt)))
plot(temp$x, temp$y, xlab="time", ylab="cases")
logistic.model <- nlsLM(y ~ (K/ (1 + ((K-m)/m)*exp(- r * x))), 
                        data = temp, 
                        start = list(K = 1, m=1, r = 0.1))
summary(logistic.model)
ys_model <- predict(logistic.model, list(x = temp$x))
lines(temp$x, ys_model)
legend("topleft", c("empirical"), pch = c(1))
title("Fitting of empirical data using logistic function")
# Test the correlation of the empirical data and the model
cor.test(temp$y, ys_model, method=c("pearson"))

```
# Estimating

The estimation is performed after the calculation of $\lambda$
 is done by:
 
 $$\lambda = r_{fit} \overline{i\ },$$
where $r_{fit}$ is the logistic growth factor obtained from 
fitting and $\overline{i }$ is the average of all isolation 
level values.

The $\lambda$ value is used to estimate the number of cases 
$n(t+dt)$ using the logistic function in the exponential form, 
substituting the parameters by the fitted ones with the exception 
of growth factor from previous time step that now depends on 
isolation level of that step and it's calculated by

$$r(t) = {\lambda\over i(i)}, $$
and the logistic function calculates the current number of cases based 
on the previous time step isolation level using:

$$n(t+dt)= {K \over 1 + ({ K-n_m \over n_m }) e^{−r(t)\, t}}$$

```{r}
# Estimation of cases using fitted parameters and 
# the mean of isolation level at each time step.
exp.logistic <- function(t, r_t, K, m) {
    y = K / (1 + ((K-m)/m)*exp(-r_t * t))
    y
}

# Calculate the constant alpha
r = coef(logistic.model)["r"]
lamb = r * mean(lvels_dt)

K = coef(logistic.model)["K"]
m = coef(logistic.model)["m"]
times = seq(from=1, to=NW-1, by=1)
cases_dt_estimated = vector("numeric", NW-1)
for (t in times) {
  r_t=alph/lvels_dt[t]
  # This is t+dt compared with empirical time
  cases_dt_estimated[t] = exp.logistic(t, r_t, K, m)
}
plot(times, cases_dt_estimated, xlab="time", ylab="cases")
points(times, cases_dt[2:NW], pch=20)
legend("topleft", c("empirical", "estimated"), pch = c(1,20))
title("Estimation of cases")
# Test the correlation of the empirical and estimated data.
cor.test(cases_dt[2:NW], cases_dt_estimated, method=c("pearson"))
```
